# 第八周作业
## 作业一
> 1. 总结几种 socket 粘包的解包方式：fix length/delimiter based/length field based frame decoder。尝试举例其应用。    

粘包与半包：
- 正常情况服务端与客户端是一条消息一条消息的读取
- 粘包问题：当一方（如客户端）发送两个数据包（如内容是ABC的数据包和内容是DEF数据包）时，另一端（如服务端）一次接收到了这两个数据包且粘合在了一起（其包内容类似 ABCDEF）的问题
- 半包：当一方（如客户端）发送了一个数据包(如内容是ABC)，另一方接收到的是数据包内容只是该包的一部分(如AB)的情况

粘包的主要原因：
- 发送方每次写入数据 < 套接字（Socket）缓冲区大小；
- 接收方读取套接字（Socket）缓冲区数据不够及时。

半包的主要原因：
- 发送方每次写入数据 > 套接字（Socket）缓冲区大小；
- 发送的数据大于协议的 MTU (Maximum Transmission Unit，最大传输单元)，因此必须拆包。

解决方案：
1. 消息定长(即fix length)
   - 控制接收方和传递方每次传递消息的长度为固定值，长度不够时使用空字符弥补。
    - 明显可见该方式增加了不必要的传输，从而增加了网络传输的负担
2. 在包结尾增加特定分隔符（即delimiter based）
    - 双方约定好在每个消息的结尾指定一个特殊字符(如`\nn`)，每次读到该字符算一次消息。
    - 这种方式如果数据量过大，查找定界符会消耗一些性能
3. 封装请求协议，根据里面的长度读取（即基于长度字段的框架解码器，length field based frame decoder）
    - 在TCP的协议基础上再封装一次，即消息头和消息体的形式，消息头中包含消息的总长度（或消息体的总长度），接收方读取到该值后，便可知道这条消息的具体边界。
    - 这种方式意味着增加了一次封包/拆包的操作，在某种程度上造成一定的延迟等问题。



## 作业二
> 2. 实现一个从 socket connection 中解码出 goim 协议的解码器。